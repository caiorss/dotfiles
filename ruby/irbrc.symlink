# vim: set filetype=ruby

# TODO - Look at: http://lucapette.com/pry/pry-everywhere/

def IRB.reload
  load __FILE__
end

require 'irb/completion'
ARGV.concat [ "--readline", "--prompt-mode", "simple" ]

# https://github.com/carlhuda/bundler/issues/183#issuecomment-1149953
# https://gist.github.com/794915
# Add all gems in the global gemset to the $LOAD_PATH so they can be used even
# in places like 'rails console'.
if defined?(::Bundler) && ENV['GEM_PATH']
  global_gemset = ENV['GEM_PATH'].split(':').grep(/ruby.*@global/).first
  $LOAD_PATH.concat Dir.glob("#{global_gemset}/gems/*/lib")
end

# Determines if a shell command exists by searching for it in ENV['PATH'].
def command_exists?(command)
  ENV['PATH'].split(File::PATH_SEPARATOR).any? {|d| File.exists? File.join(d, command) }
end

# https://github.com/cldwalker/hirb/blob/0df53628bd07845feed43030477b65106e75c7dd/lib/hirb/util.rb#L55-73
# Returns [width, height] of terminal when detected, nil if not detected.
# Think of this as a simpler version of Highline's Highline::SystemExtensions.terminal_size()
def detect_terminal_size
  if (ENV['COLUMNS'] =~ /^\d+$/) && (ENV['LINES'] =~ /^\d+$/)
    [ENV['COLUMNS'].to_i, ENV['LINES'].to_i]
  elsif (RUBY_PLATFORM =~ /java/ || (!STDIN.tty? && ENV['TERM'])) && command_exists?('tput')
    [`tput cols`.to_i, `tput lines`.to_i]
  elsif STDIN.tty? && command_exists?('stty')
    `stty size`.scan(/\d+/).map { |s| s.to_i }.reverse
  else
    nil
  end
rescue
  nil
end

begin

  if RUBY_VERSION.split('.')[1] == '8'
    require 'rubygems'
  end

  IS_IRON_RUBY = defined?(::RUBY_ENGINE) && RUBY_ENGINE == "ironruby"

  # require 'rubygems'
  require 'interactive_editor'
  require 'pp'

  if RUBY_PLATFORM =~ /mingw32/ && !IS_IRON_RUBY
    require 'Win32/Console/ANSI'
  elsif IS_IRON_RUBY
    require 'iron-term-ansicolor'

    # TOPLEVEL_BINDING#eval is screwed up in IR...
    # This is an evil hack to get interactive_editor working.
    MAIN_SELF = self
    class << TOPLEVEL_BINDING
      def eval(*args)
        MAIN_SELF
      end
    end
  end

  require 'wirble'
  Wirble.init
  Wirble.colorize unless IS_IRON_RUBY

  Wirble::Colorize.colors = Wirble::Colorize.colors.merge({
    :comma        => :light_purple,
    :refers       => :light_purple,
    :open_hash    => :light_purple,
    :close_hash   => :light_purple,
    :open_array   => :light_purple,
    :close_array  => :light_purple,
    :open_string  => :light_red,
    :string       => :dark_gray,
    :close_string => :light_red,
    :range        => :light_red,
  })

  # IronRuby has some problem with Kernel::system(cmd, *args)
  if IS_IRON_RUBY
    module InteractiveEditor::Exec
      def self.system(file, *args)
        Kernel::system([file, *args].join(" ")) #or raise "error exec'ing #{file}: #{$?}"
      end
    end
  end

  def time(times = 1)
    require 'benchmark'
    ret = nil
    Benchmark.bm { |x| x.report { times.times { ret = yield } } }
    ret
  end

  # list object methods
  def local_methods(obj=self)
    (obj.methods - obj.class.superclass.instance_methods).sort
  end

  def ls(obj=self)
    width, height = detect_terminal_size
    local_methods(obj).each_slice(3) do |meths|
      pattern = "%-#{width / 3}s" * meths.length
      puts pattern % meths
    end
  end

rescue Exception => error
  width, height = detect_terminal_size
  sep = "-" * width;

  print sep
  puts "Could not load .irbrc:"
  puts error
  puts error.backtrace.first
  print sep
end
